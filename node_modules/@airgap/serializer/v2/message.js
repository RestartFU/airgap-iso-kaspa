"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
var errors_1 = require("@airgap/coinlib-core/errors");
var ProtocolSymbols_1 = require("@airgap/coinlib-core/utils/ProtocolSymbols");
var interfaces_1 = require("./interfaces");
var serializer_1 = require("./serializer");
var generateId_1 = require("./utils/generateId");
var json_to_rlp_1 = require("./utils/json-to-rlp");
var ID_LENGTH = 10;
var Message = /** @class */ (function () {
    function Message(type, protocol, payload, id, version, serializer) {
        if (id === void 0) { id = (0, generateId_1.generateIdV2)(ID_LENGTH); }
        if (version === void 0) { version = '1'; }
        if (serializer === void 0) { serializer = serializer_1.Serializer.getInstance(); }
        this.id = id;
        this.type = type;
        this.protocol = protocol;
        this.payload = payload;
        this.version = version;
        var schemaInfo = serializer.getSchema(this.type, this.protocol);
        this.schema = (0, json_to_rlp_1.unwrapSchema)(schemaInfo.schema);
    }
    Message.prototype.asJson = function () {
        return {
            type: this.type,
            protocol: this.protocol,
            id: this.id,
            payload: this.payload
        };
    };
    Message.prototype.asArray = function () {
        var array = (0, json_to_rlp_1.jsonToArray)('root', this.schema, this.payload);
        return [this.version, this.type.toString(), this.protocol, array, this.id];
    };
    Message.fromDecoded = function (object, serializer) {
        if (serializer === void 0) { serializer = serializer_1.Serializer.getInstance(); }
        return new Message(object.type, object.protocol, object.payload, object.id, undefined, serializer);
    };
    Message.fromEncoded = function (buf, serializer) {
        if (serializer === void 0) { serializer = serializer_1.Serializer.getInstance(); }
        var version = this.parseVersion(buf[0]);
        var type = this.parseType(buf[1]);
        var protocol = this.parseProtocol(buf[2]);
        // Backwards compatiblity for version 0, before we had an ID
        var idBuf = version === '0' ? Buffer.from((0, generateId_1.generateIdV2)(ID_LENGTH)) : buf[4];
        // End Backwards compatibility
        var id = this.parseId(idBuf);
        var encodedPayload = this.parsePayload(buf[3]);
        var schemaInfo = serializer_1.Serializer.getSchema(type, protocol);
        var schema = (0, json_to_rlp_1.unwrapSchema)(schemaInfo.schema);
        var schemaTransformer = schemaInfo.transformer;
        var json = (0, json_to_rlp_1.rlpArrayToJson)(schema, encodedPayload);
        var payload = schemaTransformer ? schemaTransformer(json) : json;
        return new Message(type, protocol, payload, id, version, serializer);
    };
    Message.parseVersion = function (buffer) {
        return this.validateProperty('Version', buffer, function (buf) { return buf.toString(); }, function (val) { return val === '0' || val === '1'; });
    };
    Message.parseType = function (buffer) {
        return this.validateProperty('Type', buffer, function (buf) { return parseInt(buf.toString(), 10); }, function (val) { return Object.values(interfaces_1.IACMessageType).includes(val); });
    };
    Message.parseProtocol = function (buffer) {
        return this.validateProperty('Protocol', buffer, function (buf) { return buf.toString(); }, function (val) { return val.length === 0 || Object.values(ProtocolSymbols_1.MainProtocolSymbols).some(function (value) { return val.split('-')[0] === value; }); });
    };
    Message.parseId = function (buffer) {
        return this.validateProperty('Id', buffer, function (buf) { return buf.toString(); }, function (val) { return val.length === ID_LENGTH; });
    };
    Message.parsePayload = function (buffer) {
        return this.validateProperty('Payload', buffer, function (buf) { return buf; }, function () { return true; });
    };
    Message.validateProperty = function (property, buffer, parse, validate) {
        if (typeof buffer === 'undefined') {
            throw new errors_1.SerializerError(errors_1.SerializerErrorType.PROPERTY_IS_EMPTY, "".concat(property, " is empty"));
        }
        var parsed = parse(buffer);
        if (validate(parsed)) {
            return parsed; // TODO: Use type guard?
        }
        throw new errors_1.SerializerError(errors_1.SerializerErrorType.PROPERTY_IS_EMPTY, "".concat(property, " is invalid: \"").concat(parsed, "\""));
    };
    return Message;
}());
exports.Message = Message;
//# sourceMappingURL=message.js.map