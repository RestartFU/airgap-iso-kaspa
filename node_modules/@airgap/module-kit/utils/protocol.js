"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.protocolNetworkIdentifier = exports.supportsWalletConnect = exports.isTransactionStatusChecker = exports.hasConfigurableTransactionInjector = exports.canSignMessage = exports.canEncryptAsymmetric = exports.canEncryptAES = exports.hasConfigurableContract = exports.hasMultiAddressPublicKeys = exports.canFetchDataForMultipleAddresses = exports.canFetchDataForAddress = exports.canGetTokenBalances = exports.isMultiTokenSubProtocol = exports.isSingleTokenSubProtocol = exports.isSubProtocol = exports.isBip32Protocol = exports.isOnlineProtocol = exports.isOfflineProtocol = exports.isAnyProtocol = exports.isMultisig = exports.walletConnectProtocolSchema = exports.transactionStatusCheckerSchema = exports.configurableTransactionInjectorSchema = exports.signMessageOfflineSchema = exports.signMessageBaseSchema = exports.asymmetricEncryptionOfflineSchema = exports.asymmetricEncryptionBaseSchema = exports.aesEncryptionSchema = exports.configurableContractProtocolSchema = exports.multiAddressPublicKeyProtocolSchema = exports.fetchDataForMultipleAddressesProtocolSchema = exports.fetchDataForAddressProtocolSchema = exports.getTokenBalancesSchema = exports.multiTokenSubProtocolOnlineSchema = exports.multiTokenSubProtocolBaseSchema = exports.singleTokenSubProtocolSchema = exports.subProtocolSchema = exports.bip32OnlineProtocolSchema = exports.bip32OfflineProtocolSchema = exports.bip32BaseProtocolSchema = exports.onlineProtocolSchema = exports.offlineProtocolSchema = exports.baseProtocolSchema = exports.multisigSchema = void 0;
// @ts-ignore
var createHash = require("@airgap/coinlib-core/dependencies/src/create-hash-1.2.0/index");
var interface_1 = require("./interface");
// Schemas
exports.multisigSchema = {
    getMultisigStatus: 'required'
    // getSigners: 'required',
    // addSigner: 'required',
    // removeSigner: 'required'
};
exports.baseProtocolSchema = {
    getAddressFromPublicKey: 'required',
    getDetailsFromTransaction: 'required',
    getMetadata: 'required'
};
exports.offlineProtocolSchema = __assign(__assign({}, exports.baseProtocolSchema), { getCryptoConfiguration: 'required', getKeyPairFromDerivative: 'required', signTransactionWithSecretKey: 'required' });
exports.onlineProtocolSchema = __assign(__assign({}, exports.baseProtocolSchema), { broadcastTransaction: 'required', getBalanceOfPublicKey: 'required', getNetwork: 'required', getTransactionFeeWithPublicKey: 'required', getTransactionMaxAmountWithPublicKey: 'required', getTransactionsForPublicKey: 'required', prepareTransactionWithPublicKey: 'required' });
exports.bip32BaseProtocolSchema = __assign(__assign({}, exports.baseProtocolSchema), { deriveFromExtendedPublicKey: 'required' });
exports.bip32OfflineProtocolSchema = __assign(__assign(__assign({}, exports.bip32BaseProtocolSchema), exports.offlineProtocolSchema), { getExtendedKeyPairFromDerivative: 'required', deriveFromExtendedSecretKey: 'required' });
exports.bip32OnlineProtocolSchema = __assign(__assign({}, exports.bip32BaseProtocolSchema), exports.onlineProtocolSchema);
exports.subProtocolSchema = {
    getType: 'required',
    mainProtocol: 'required'
};
exports.singleTokenSubProtocolSchema = __assign(__assign({}, exports.subProtocolSchema), { getContractAddress: 'required' });
exports.multiTokenSubProtocolBaseSchema = exports.singleTokenSubProtocolSchema;
exports.multiTokenSubProtocolOnlineSchema = __assign(__assign({}, exports.multiTokenSubProtocolBaseSchema), exports.onlineProtocolSchema);
exports.getTokenBalancesSchema = {
    getTokenBalancesOfPublicKey: 'required'
};
exports.fetchDataForAddressProtocolSchema = {
    getBalanceOfAddress: 'required',
    getTransactionsForAddress: 'required'
};
exports.fetchDataForMultipleAddressesProtocolSchema = {
    getBalanceOfAddresses: 'required',
    getTransactionsForAddresses: 'required'
};
exports.multiAddressPublicKeyProtocolSchema = {
    getInitialAddressesFromPublicKey: 'required',
    getNextAddressFromPublicKey: 'required'
};
exports.configurableContractProtocolSchema = {
    isContractValid: 'required',
    getContractAddress: 'required',
    setContractAddress: 'required'
};
exports.aesEncryptionSchema = {
    decryptAESWithSecretKey: 'required',
    encryptAESWithSecretKey: 'required'
};
exports.asymmetricEncryptionBaseSchema = {
    encryptAsymmetricWithPublicKey: 'required'
};
exports.asymmetricEncryptionOfflineSchema = __assign(__assign({}, exports.asymmetricEncryptionBaseSchema), { decryptAsymmetricWithKeyPair: 'required' });
exports.signMessageBaseSchema = {
    verifyMessageWithPublicKey: 'required'
};
exports.signMessageOfflineSchema = __assign(__assign({}, exports.signMessageBaseSchema), { signMessageWithKeyPair: 'required' });
exports.configurableTransactionInjectorSchema = {
    getInjectorUrl: 'required',
    setInjectorUrl: 'required'
};
exports.transactionStatusCheckerSchema = {
    getTransactionStatus: 'required'
};
exports.walletConnectProtocolSchema = {
    getWalletConnectChain: 'required',
    prepareWalletConnectTransactionWithPublicKey: 'required'
};
// Implementation Checks
function isMultisig(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.multisigSchema);
}
exports.isMultisig = isMultisig;
function isAnyProtocol(object) {
    return isOfflineProtocol(object) || isOnlineProtocol(object);
}
exports.isAnyProtocol = isAnyProtocol;
function isOfflineProtocol(object) {
    return (0, interface_1.implementsInterface)(object, exports.offlineProtocolSchema);
}
exports.isOfflineProtocol = isOfflineProtocol;
function isOnlineProtocol(object) {
    return (0, interface_1.implementsInterface)(object, exports.onlineProtocolSchema);
}
exports.isOnlineProtocol = isOnlineProtocol;
function isOfflineBip32Protocol(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.bip32OfflineProtocolSchema);
}
function isOnlineBip32Protocol(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.bip32OnlineProtocolSchema);
}
function isBip32Protocol(protocol) {
    var extendedWithBip32 = false;
    if (isOfflineProtocol(protocol)) {
        extendedWithBip32 = isOfflineBip32Protocol(protocol);
    }
    if (isOnlineProtocol(protocol)) {
        extendedWithBip32 && (extendedWithBip32 = isOnlineBip32Protocol(protocol));
    }
    return extendedWithBip32;
}
exports.isBip32Protocol = isBip32Protocol;
function isSubProtocol(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.subProtocolSchema);
}
exports.isSubProtocol = isSubProtocol;
function isSingleTokenSubProtocol(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.singleTokenSubProtocolSchema);
}
exports.isSingleTokenSubProtocol = isSingleTokenSubProtocol;
function isMultiTokenSubProtocol(protocol) {
    var extendedWithMultiTokenSubProtocol = (0, interface_1.implementsInterface)(protocol, exports.multiTokenSubProtocolBaseSchema);
    if (isOnlineProtocol(protocol)) {
        extendedWithMultiTokenSubProtocol && (extendedWithMultiTokenSubProtocol = (0, interface_1.implementsInterface)(protocol, exports.multiTokenSubProtocolOnlineSchema));
    }
    return extendedWithMultiTokenSubProtocol;
}
exports.isMultiTokenSubProtocol = isMultiTokenSubProtocol;
function canGetTokenBalances(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.getTokenBalancesSchema);
}
exports.canGetTokenBalances = canGetTokenBalances;
function canFetchDataForAddress(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.fetchDataForAddressProtocolSchema);
}
exports.canFetchDataForAddress = canFetchDataForAddress;
function canFetchDataForMultipleAddresses(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.fetchDataForMultipleAddressesProtocolSchema);
}
exports.canFetchDataForMultipleAddresses = canFetchDataForMultipleAddresses;
function hasMultiAddressPublicKeys(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.multiAddressPublicKeyProtocolSchema);
}
exports.hasMultiAddressPublicKeys = hasMultiAddressPublicKeys;
function hasConfigurableContract(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.configurableContractProtocolSchema);
}
exports.hasConfigurableContract = hasConfigurableContract;
function canEncryptAES(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.aesEncryptionSchema);
}
exports.canEncryptAES = canEncryptAES;
function canEncryptAsymmetric(protocol) {
    var extendedWithAsymmetricEncryption = (0, interface_1.implementsInterface)(protocol, exports.asymmetricEncryptionBaseSchema);
    if (isOfflineProtocol(protocol)) {
        extendedWithAsymmetricEncryption && (extendedWithAsymmetricEncryption = (0, interface_1.implementsInterface)(protocol, exports.asymmetricEncryptionOfflineSchema));
    }
    return extendedWithAsymmetricEncryption;
}
exports.canEncryptAsymmetric = canEncryptAsymmetric;
function canSignMessage(protocol) {
    var extendedWithSignMessage = (0, interface_1.implementsInterface)(protocol, exports.signMessageBaseSchema);
    if (isOfflineProtocol(protocol)) {
        extendedWithSignMessage && (extendedWithSignMessage = (0, interface_1.implementsInterface)(protocol, exports.signMessageOfflineSchema));
    }
    return extendedWithSignMessage;
}
exports.canSignMessage = canSignMessage;
function hasConfigurableTransactionInjector(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.configurableTransactionInjectorSchema);
}
exports.hasConfigurableTransactionInjector = hasConfigurableTransactionInjector;
function isTransactionStatusChecker(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.transactionStatusCheckerSchema);
}
exports.isTransactionStatusChecker = isTransactionStatusChecker;
function supportsWalletConnect(protocol) {
    return (0, interface_1.implementsInterface)(protocol, exports.walletConnectProtocolSchema);
}
exports.supportsWalletConnect = supportsWalletConnect;
// Identifier
var sha256hashShort = function (input) {
    var hash = createHash('sha256');
    hash.update(input);
    return hash.digest('base64').slice(0, 10);
};
function protocolNetworkIdentifier(network) {
    var hashed = sha256hashShort("".concat(network.name, "-").concat(network.rpcUrl));
    return "".concat(network.type, "-").concat(hashed);
}
exports.protocolNetworkIdentifier = protocolNetworkIdentifier;
//# sourceMappingURL=protocol.js.map