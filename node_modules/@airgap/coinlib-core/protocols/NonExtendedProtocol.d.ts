import { IAirGapAddressResult } from '../interfaces/IAirGapAddress';
import { IAirGapTransactionResult, IProtocolTransactionCursor } from '../interfaces/IAirGapTransaction';
import { FeeDefaults } from './ICoinProtocol';
export declare abstract class NonExtendedProtocol {
    getExtendedPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;
    getExtendedPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;
    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;
    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;
    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset: number): Promise<string>;
    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: any, childDerivationPath: string): Promise<string>;
    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<IAirGapAddressResult>;
    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<IAirGapAddressResult[]>;
    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee: string): Promise<string>;
    estimateFeeDefaultsFromExtendedPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;
    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;
    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string): Promise<any>;
}
