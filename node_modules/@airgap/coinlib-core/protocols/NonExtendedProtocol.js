"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonExtendedProtocol = void 0;
var NonExtendedProtocol = /** @class */ (function () {
    function NonExtendedProtocol() {
    }
    NonExtendedProtocol.prototype.getExtendedPublicKeyFromMnemonic = function (mnemonic, derivationPath, password) {
        throw Promise.reject('extended public key support not implemented');
    };
    NonExtendedProtocol.prototype.getExtendedPublicKeyFromHexSecret = function (secret, derivationPath) {
        throw Promise.reject('extended public key support not implemented');
    };
    NonExtendedProtocol.prototype.getExtendedPrivateKeyFromMnemonic = function (mnemonic, derivationPath, password) {
        throw Promise.reject('extended private key support not implemented');
    };
    NonExtendedProtocol.prototype.getExtendedPrivateKeyFromHexSecret = function (secret, derivationPath) {
        throw Promise.reject('extended private key support not implemented');
    };
    NonExtendedProtocol.prototype.getBalanceOfExtendedPublicKey = function (extendedPublicKey, offset) {
        return Promise.reject('extended public balance not implemented');
    };
    NonExtendedProtocol.prototype.signWithExtendedPrivateKey = function (extendedPrivateKey, transaction, childDerivationPath) {
        return Promise.reject('extended private key signing for not implemented');
    };
    NonExtendedProtocol.prototype.getAddressFromExtendedPublicKey = function (extendedPublicKey, visibilityDerivationIndex, addressDerivationIndex) {
        return Promise.resolve({
            address: '',
            cursor: { hasNext: false }
        });
    };
    NonExtendedProtocol.prototype.getAddressesFromExtendedPublicKey = function (extendedPublicKey, visibilityDerivationIndex, addressCount, offset) {
        return Promise.resolve([]);
    };
    NonExtendedProtocol.prototype.estimateMaxTransactionValueFromExtendedPublicKey = function (extendedPublicKey, recipients, fee) {
        return Promise.reject('estimating max value using extended public key not implemented');
    };
    NonExtendedProtocol.prototype.estimateFeeDefaultsFromExtendedPublicKey = function (publicKey, recipients, values, data) {
        return Promise.reject('estimating fee defaults using extended public key not implemented');
    };
    NonExtendedProtocol.prototype.getTransactionsFromExtendedPublicKey = function (extendedPublicKey, limit, cursor) {
        return Promise.reject('fetching txs using extended public key not implemented');
    };
    NonExtendedProtocol.prototype.prepareTransactionFromExtendedPublicKey = function (extendedPublicKey, offset, recipients, values, fee) {
        return Promise.reject('extended public key tx not implemented');
    };
    return NonExtendedProtocol;
}());
exports.NonExtendedProtocol = NonExtendedProtocol;
//# sourceMappingURL=NonExtendedProtocol.js.map