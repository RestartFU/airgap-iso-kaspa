import { AxiosError } from '../dependencies/src/axios-0.19.0';
import { CoinlibError, Domain } from './coinlib-error';
export declare enum SerializerErrorType {
    SERIALIZER_VERSION_MISMATCH = "SERIALIZER_VERSION_MISMATCH",
    PROTOCOL_NOT_SUPPORTED = "PROTOCOL_NOT_SUPPORTED",
    PROTOCOL_VERSION_MISMATCH = "PROTOCOL_VERSION_MISMATCH",
    TYPE_NOT_SUPPORTED = "TYPE_NOT_SUPPORTED",
    INVALID_SCHEMA = "INVALID_SCHEMA",
    INVALID_SCHEMA_TYPE = "INVALID_SCHEMA_TYPE",
    INVALID_PAYLOAD = "INVALID_PAYLOAD",
    INVALID_HEX_STRING = "INVALID_HEX_STRING",
    INVALID_STRING = "INVALID_STRING",
    SCHEMA_ALREADY_EXISTS = "SCHEMA_ALREADY_EXISTS",
    SCHEMA_DOES_NOT_EXISTS = "SCHEMA_DOES_NOT_EXISTS",
    UNEXPECTED_PAYLOAD = "UNEXPECTED_PAYLOAD",
    PAYLOAD_TYPE_UNKNOWN = "PAYLOAD_TYPE_UNKNOWN",
    PAYLOAD_TYPE_MISMATCH = "PAYLOAD_TYPE_MISMATCH",
    PAYLOAD_TYPE_NOT_SUPPORTED = "PAYLOAD_TYPE_NOT_SUPPORTED",
    PROPERTY_IS_EMPTY = "PROPERTY_IS_EMPTY",
    PROPERTY_INVALID = "PROPERTY_INVALID"
}
export declare enum ProtocolErrorType {
    NETWORK = "NETWORK",
    CONDITION_VIOLATION = "CONDITION_VIOLATION",
    UNSUPPORTED = "UNSUPPORTED",
    NOT_FOUND = "NOT_FOUND",
    BALANCE = "BALANCE",
    PROPERTY_UNDEFINED = "PROPERTY_UNDEFINED",
    OPERATION_FAILED = "OPERATION_FAILED",
    NOT_IMPLEMENTED = "NOT_IMPLEMENTED",
    INVALID_VALUE = "INVALID_VALUE",
    TRANSACTION_FAILED = "TRANSACTION_FAILED"
}
/**
 * Gets thrown if an error occurs when making a network request
 * Partial<AxiosError> is either an AxiosError or an AxiosResponse,
 * as we sometimes want to throw an Error even though we get a 200 response
 * from the API (as in case of internal operation errors for Tezos).
 */
export declare class NetworkError extends CoinlibError {
    data: string;
    status: number | undefined;
    url: string | undefined;
    method: string | undefined;
    requestBody?: unknown;
    constructor(domain: Domain, error: Partial<AxiosError>, description?: string);
}
/**
 * Gets thrown if a value ist expected to fulfill a certain condition such as having a certain length, but the condition is not satisfied
 */
export declare class ConditionViolationError extends CoinlibError {
    constructor(domain: Domain, description?: string);
}
/**
 * Gets thrown if a variable assumes a value for which an operation is not supported
 */
export declare class UnsupportedError extends CoinlibError {
    constructor(domain: Domain, description?: string);
}
/**
 * Gets thrown if a variable is unexpectedly undefined
 */
export declare class NotFoundError extends CoinlibError {
    constructor(domain: Domain, description?: string);
}
/**
 * Gets thrown if an account has an insufficient balance to perform a certain kind of operation
 */
export declare class BalanceError extends CoinlibError {
    constructor(domain: Domain, description?: string);
}
export declare class TransactionError extends CoinlibError {
    data?: unknown;
    constructor(domain: Domain, description?: string, data?: unknown);
}
/**
 * Gets thrown if an accessed object property is undefined
 */
export declare class PropertyUndefinedError extends CoinlibError {
    constructor(domain: Domain, description?: string);
}
/**
 * Gets thrown if an internal method fails
 */
export declare class OperationFailedError extends CoinlibError {
    constructor(domain: Domain, description?: string);
}
/**
 * Gets thrown if a method is executed which is not implemented
 */
export declare class NotImplementedError extends CoinlibError {
    constructor(domain: Domain, description?: string);
}
/**
 * Gets thrown if a variable has a value which cannot be handled
 */
export declare class InvalidValueError extends CoinlibError {
    constructor(domain: Domain, description?: string);
}
export declare class SerializerError extends CoinlibError {
    constructor(code: string, description?: string);
}
/**
 * Gets thrown if the serializer version does not match
 */
export declare class SerializerVersionMismatch extends SerializerError {
    constructor(description?: string);
}
/**
 * Gets thrown if the serializer cannot handle the specified coin/protocol
 */
export declare class ProtocolNotSupported extends SerializerError {
    constructor(description?: string);
}
/**
 * Gets thrown if the serializer CAN handle the specified coin/protocol, but not in this version
 */
export declare class ProtocolVersionMismatch extends SerializerError {
    constructor(description?: string);
}
/**
 * Gets thrown if the specified Type is not supported
 */
export declare class TypeNotSupported extends SerializerError {
    constructor(description?: string);
}
/**
 * Gets thrown if the schema in the serializer is invalid
 */
export declare class InvalidSchema extends SerializerError {
    constructor(description?: string);
}
/**
 * Gets thrown if the 2 types provided are not compatible
 */
export declare class InvalidSchemaType extends SerializerError {
    constructor(description?: string);
}
/**
 * Gets thrown if the payload that is being decoded does not match the schema
 */
export declare class InvalidPayloadError extends SerializerError {
    constructor(description?: string);
}
/**
 * Gets thrown if the string is not a valid hex string
 */
export declare class InvalidHexString extends SerializerError {
    constructor(description?: string);
}
/**
 * Gets thrown if the string starts with "0x". This causes problems with RLP
 */
export declare class InvalidString extends SerializerError {
    constructor(description?: string);
}
