"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidString = exports.InvalidHexString = exports.InvalidPayloadError = exports.InvalidSchemaType = exports.InvalidSchema = exports.TypeNotSupported = exports.ProtocolVersionMismatch = exports.ProtocolNotSupported = exports.SerializerVersionMismatch = exports.SerializerError = exports.InvalidValueError = exports.NotImplementedError = exports.OperationFailedError = exports.PropertyUndefinedError = exports.TransactionError = exports.BalanceError = exports.NotFoundError = exports.UnsupportedError = exports.ConditionViolationError = exports.NetworkError = exports.ProtocolErrorType = exports.SerializerErrorType = void 0;
var coinlib_error_1 = require("./coinlib-error");
var SerializerErrorType;
(function (SerializerErrorType) {
    SerializerErrorType["SERIALIZER_VERSION_MISMATCH"] = "SERIALIZER_VERSION_MISMATCH";
    SerializerErrorType["PROTOCOL_NOT_SUPPORTED"] = "PROTOCOL_NOT_SUPPORTED";
    SerializerErrorType["PROTOCOL_VERSION_MISMATCH"] = "PROTOCOL_VERSION_MISMATCH";
    SerializerErrorType["TYPE_NOT_SUPPORTED"] = "TYPE_NOT_SUPPORTED";
    SerializerErrorType["INVALID_SCHEMA"] = "INVALID_SCHEMA";
    SerializerErrorType["INVALID_SCHEMA_TYPE"] = "INVALID_SCHEMA_TYPE";
    SerializerErrorType["INVALID_PAYLOAD"] = "INVALID_PAYLOAD";
    SerializerErrorType["INVALID_HEX_STRING"] = "INVALID_HEX_STRING";
    SerializerErrorType["INVALID_STRING"] = "INVALID_STRING";
    SerializerErrorType["SCHEMA_ALREADY_EXISTS"] = "SCHEMA_ALREADY_EXISTS";
    SerializerErrorType["SCHEMA_DOES_NOT_EXISTS"] = "SCHEMA_DOES_NOT_EXISTS";
    SerializerErrorType["UNEXPECTED_PAYLOAD"] = "UNEXPECTED_PAYLOAD";
    SerializerErrorType["PAYLOAD_TYPE_UNKNOWN"] = "PAYLOAD_TYPE_UNKNOWN";
    SerializerErrorType["PAYLOAD_TYPE_MISMATCH"] = "PAYLOAD_TYPE_MISMATCH";
    SerializerErrorType["PAYLOAD_TYPE_NOT_SUPPORTED"] = "PAYLOAD_TYPE_NOT_SUPPORTED";
    SerializerErrorType["PROPERTY_IS_EMPTY"] = "PROPERTY_IS_EMPTY";
    SerializerErrorType["PROPERTY_INVALID"] = "PROPERTY_INVALID";
})(SerializerErrorType = exports.SerializerErrorType || (exports.SerializerErrorType = {}));
var ProtocolErrorType;
(function (ProtocolErrorType) {
    ProtocolErrorType["NETWORK"] = "NETWORK";
    ProtocolErrorType["CONDITION_VIOLATION"] = "CONDITION_VIOLATION";
    ProtocolErrorType["UNSUPPORTED"] = "UNSUPPORTED";
    ProtocolErrorType["NOT_FOUND"] = "NOT_FOUND";
    ProtocolErrorType["BALANCE"] = "BALANCE";
    ProtocolErrorType["PROPERTY_UNDEFINED"] = "PROPERTY_UNDEFINED";
    ProtocolErrorType["OPERATION_FAILED"] = "OPERATION_FAILED";
    ProtocolErrorType["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    ProtocolErrorType["INVALID_VALUE"] = "INVALID_VALUE";
    ProtocolErrorType["TRANSACTION_FAILED"] = "TRANSACTION_FAILED";
})(ProtocolErrorType = exports.ProtocolErrorType || (exports.ProtocolErrorType = {}));
/**
 * Gets thrown if an error occurs when making a network request
 * Partial<AxiosError> is either an AxiosError or an AxiosResponse,
 * as we sometimes want to throw an Error even though we get a 200 response
 * from the API (as in case of internal operation errors for Tezos).
 */
var NetworkError = /** @class */ (function (_super) {
    __extends(NetworkError, _super);
    function NetworkError(domain, error, description) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        _this = _super.call(this, domain, ProtocolErrorType.NETWORK) || this;
        _this.data = description !== null && description !== void 0 ? description : (_a = error.response) === null || _a === void 0 ? void 0 : _a.data;
        _this.status = (_b = error === null || error === void 0 ? void 0 : error.response) === null || _b === void 0 ? void 0 : _b.status;
        _this.url = (_c = error.config) === null || _c === void 0 ? void 0 : _c.url;
        _this.method = (_d = error.config) === null || _d === void 0 ? void 0 : _d.method;
        _this.requestBody = (_e = error.config) === null || _e === void 0 ? void 0 : _e.data;
        return _this;
    }
    return NetworkError;
}(coinlib_error_1.CoinlibError));
exports.NetworkError = NetworkError;
/**
 * Gets thrown if a value ist expected to fulfill a certain condition such as having a certain length, but the condition is not satisfied
 */
var ConditionViolationError = /** @class */ (function (_super) {
    __extends(ConditionViolationError, _super);
    function ConditionViolationError(domain, description) {
        return _super.call(this, domain, ProtocolErrorType.CONDITION_VIOLATION, description) || this;
    }
    return ConditionViolationError;
}(coinlib_error_1.CoinlibError));
exports.ConditionViolationError = ConditionViolationError;
/**
 * Gets thrown if a variable assumes a value for which an operation is not supported
 */
var UnsupportedError = /** @class */ (function (_super) {
    __extends(UnsupportedError, _super);
    function UnsupportedError(domain, description) {
        return _super.call(this, domain, ProtocolErrorType.UNSUPPORTED, description) || this;
    }
    return UnsupportedError;
}(coinlib_error_1.CoinlibError));
exports.UnsupportedError = UnsupportedError;
/**
 * Gets thrown if a variable is unexpectedly undefined
 */
var NotFoundError = /** @class */ (function (_super) {
    __extends(NotFoundError, _super);
    function NotFoundError(domain, description) {
        return _super.call(this, domain, ProtocolErrorType.NOT_FOUND, description) || this;
    }
    return NotFoundError;
}(coinlib_error_1.CoinlibError));
exports.NotFoundError = NotFoundError;
/**
 * Gets thrown if an account has an insufficient balance to perform a certain kind of operation
 */
var BalanceError = /** @class */ (function (_super) {
    __extends(BalanceError, _super);
    function BalanceError(domain, description) {
        return _super.call(this, domain, ProtocolErrorType.BALANCE, description) || this;
    }
    return BalanceError;
}(coinlib_error_1.CoinlibError));
exports.BalanceError = BalanceError;
var TransactionError = /** @class */ (function (_super) {
    __extends(TransactionError, _super);
    function TransactionError(domain, description, data) {
        var _this = _super.call(this, domain, ProtocolErrorType.TRANSACTION_FAILED, description) || this;
        _this.data = data;
        return _this;
    }
    return TransactionError;
}(coinlib_error_1.CoinlibError));
exports.TransactionError = TransactionError;
/**
 * Gets thrown if an accessed object property is undefined
 */
var PropertyUndefinedError = /** @class */ (function (_super) {
    __extends(PropertyUndefinedError, _super);
    function PropertyUndefinedError(domain, description) {
        return _super.call(this, domain, ProtocolErrorType.PROPERTY_UNDEFINED, description) || this;
    }
    return PropertyUndefinedError;
}(coinlib_error_1.CoinlibError));
exports.PropertyUndefinedError = PropertyUndefinedError;
/**
 * Gets thrown if an internal method fails
 */
var OperationFailedError = /** @class */ (function (_super) {
    __extends(OperationFailedError, _super);
    function OperationFailedError(domain, description) {
        return _super.call(this, domain, ProtocolErrorType.OPERATION_FAILED, description) || this;
    }
    return OperationFailedError;
}(coinlib_error_1.CoinlibError));
exports.OperationFailedError = OperationFailedError;
/**
 * Gets thrown if a method is executed which is not implemented
 */
var NotImplementedError = /** @class */ (function (_super) {
    __extends(NotImplementedError, _super);
    function NotImplementedError(domain, description) {
        return _super.call(this, domain, ProtocolErrorType.NOT_IMPLEMENTED, description) || this;
    }
    return NotImplementedError;
}(coinlib_error_1.CoinlibError));
exports.NotImplementedError = NotImplementedError;
/**
 * Gets thrown if a variable has a value which cannot be handled
 */
var InvalidValueError = /** @class */ (function (_super) {
    __extends(InvalidValueError, _super);
    function InvalidValueError(domain, description) {
        return _super.call(this, domain, ProtocolErrorType.INVALID_VALUE, description) || this;
    }
    return InvalidValueError;
}(coinlib_error_1.CoinlibError));
exports.InvalidValueError = InvalidValueError;
var SerializerError = /** @class */ (function (_super) {
    __extends(SerializerError, _super);
    function SerializerError(code, description) {
        return _super.call(this, coinlib_error_1.Domain.SERIALIZER, code, description) || this;
    }
    return SerializerError;
}(coinlib_error_1.CoinlibError));
exports.SerializerError = SerializerError;
// tslint:disable:max-classes-per-file
/**
 * Gets thrown if the serializer version does not match
 */
var SerializerVersionMismatch = /** @class */ (function (_super) {
    __extends(SerializerVersionMismatch, _super);
    function SerializerVersionMismatch(description) {
        return _super.call(this, SerializerErrorType.SERIALIZER_VERSION_MISMATCH, description) || this;
    }
    return SerializerVersionMismatch;
}(SerializerError));
exports.SerializerVersionMismatch = SerializerVersionMismatch;
/**
 * Gets thrown if the serializer cannot handle the specified coin/protocol
 */
var ProtocolNotSupported = /** @class */ (function (_super) {
    __extends(ProtocolNotSupported, _super);
    function ProtocolNotSupported(description) {
        return _super.call(this, SerializerErrorType.PROTOCOL_NOT_SUPPORTED, description) || this;
    }
    return ProtocolNotSupported;
}(SerializerError));
exports.ProtocolNotSupported = ProtocolNotSupported;
/**
 * Gets thrown if the serializer CAN handle the specified coin/protocol, but not in this version
 */
var ProtocolVersionMismatch = /** @class */ (function (_super) {
    __extends(ProtocolVersionMismatch, _super);
    function ProtocolVersionMismatch(description) {
        return _super.call(this, SerializerErrorType.PROTOCOL_VERSION_MISMATCH, description) || this;
    }
    return ProtocolVersionMismatch;
}(SerializerError));
exports.ProtocolVersionMismatch = ProtocolVersionMismatch;
/**
 * Gets thrown if the specified Type is not supported
 */
var TypeNotSupported = /** @class */ (function (_super) {
    __extends(TypeNotSupported, _super);
    function TypeNotSupported(description) {
        return _super.call(this, SerializerErrorType.TYPE_NOT_SUPPORTED, description) || this;
    }
    return TypeNotSupported;
}(SerializerError));
exports.TypeNotSupported = TypeNotSupported;
/**
 * Gets thrown if the schema in the serializer is invalid
 */
var InvalidSchema = /** @class */ (function (_super) {
    __extends(InvalidSchema, _super);
    function InvalidSchema(description) {
        return _super.call(this, SerializerErrorType.INVALID_SCHEMA, description) || this;
    }
    return InvalidSchema;
}(SerializerError));
exports.InvalidSchema = InvalidSchema;
/**
 * Gets thrown if the 2 types provided are not compatible
 */
var InvalidSchemaType = /** @class */ (function (_super) {
    __extends(InvalidSchemaType, _super);
    function InvalidSchemaType(description) {
        return _super.call(this, SerializerErrorType.INVALID_SCHEMA_TYPE, description) || this;
    }
    return InvalidSchemaType;
}(SerializerError));
exports.InvalidSchemaType = InvalidSchemaType;
/**
 * Gets thrown if the payload that is being decoded does not match the schema
 */
var InvalidPayloadError = /** @class */ (function (_super) {
    __extends(InvalidPayloadError, _super);
    function InvalidPayloadError(description) {
        return _super.call(this, SerializerErrorType.INVALID_PAYLOAD, description) || this;
    }
    return InvalidPayloadError;
}(SerializerError));
exports.InvalidPayloadError = InvalidPayloadError;
/**
 * Gets thrown if the string is not a valid hex string
 */
var InvalidHexString = /** @class */ (function (_super) {
    __extends(InvalidHexString, _super);
    function InvalidHexString(description) {
        return _super.call(this, SerializerErrorType.INVALID_HEX_STRING, description) || this;
    }
    return InvalidHexString;
}(SerializerError));
exports.InvalidHexString = InvalidHexString;
/**
 * Gets thrown if the string starts with "0x". This causes problems with RLP
 */
var InvalidString = /** @class */ (function (_super) {
    __extends(InvalidString, _super);
    function InvalidString(description) {
        return _super.call(this, SerializerErrorType.INVALID_STRING, description) || this;
    }
    return InvalidString;
}(SerializerError));
exports.InvalidString = InvalidString;
//# sourceMappingURL=index.js.map