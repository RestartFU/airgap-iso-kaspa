"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeTxBytes = exports.encodeTxBytes = exports.prepareSignBytes = void 0;
var long_1 = __importDefault(require("long"));
var minimal_js_1 = __importDefault(require("protobufjs/minimal.js"));
var base64js = __importStar(require("base64-js"));
function isTsProtoGeneratedType(type) {
    return typeof type.fromPartial === 'function';
}
var MsgSend = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.fromAddress !== '') {
            writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== '') {
            writer.uint32(18).string(message.toAddress);
        }
        for (var _i = 0, _a = message.amount; _i < _a.length; _i++) {
            var v = _a[_i];
            Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseMsgSend);
        message.amount = [];
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fromAddress = reader.string();
                    break;
                case 2:
                    message.toAddress = reader.string();
                    break;
                case 3:
                    message.amount.push(Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var _a;
        var message = __assign({}, baseMsgSend);
        message.fromAddress = object.fromAddress !== undefined && object.fromAddress !== null ? String(object.fromAddress) : '';
        message.toAddress = object.toAddress !== undefined && object.toAddress !== null ? String(object.toAddress) : '';
        message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map(function (e) { return Coin.fromJSON(e); });
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.fromAddress !== undefined && (obj.fromAddress = message.fromAddress);
        message.toAddress !== undefined && (obj.toAddress = message.toAddress);
        if (message.amount) {
            obj.amount = message.amount.map(function (e) { return (e ? Coin.toJSON(e) : undefined); });
        }
        else {
            obj.amount = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = __assign({}, baseMsgSend);
        message.fromAddress = (_a = object.fromAddress) !== null && _a !== void 0 ? _a : '';
        message.toAddress = (_b = object.toAddress) !== null && _b !== void 0 ? _b : '';
        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map(function (e) { return Coin.fromPartial(e); })) || [];
        return message;
    }
};
var MsgWithdrawDelegatorReward = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.delegatorAddress !== '') {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== '') {
            writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseMsgWithdrawDelegatorReward);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseMsgWithdrawDelegatorReward);
        message.delegatorAddress =
            object.delegatorAddress !== undefined && object.delegatorAddress !== null ? String(object.delegatorAddress) : '';
        message.validatorAddress =
            object.validatorAddress !== undefined && object.validatorAddress !== null ? String(object.validatorAddress) : '';
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = __assign({}, baseMsgWithdrawDelegatorReward);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : '';
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : '';
        return message;
    }
};
var baseSignDoc = { chainId: '', accountNumber: long_1.default.UZERO };
var SignDoc = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.bodyBytes.length !== 0) {
            writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
            writer.uint32(18).bytes(message.authInfoBytes);
        }
        if (message.chainId !== '') {
            writer.uint32(26).string(message.chainId);
        }
        if (!message.accountNumber.isZero()) {
            writer.uint32(32).uint64(message.accountNumber);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseSignDoc);
        message.bodyBytes = new Uint8Array();
        message.authInfoBytes = new Uint8Array();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bodyBytes = reader.bytes();
                    break;
                case 2:
                    message.authInfoBytes = reader.bytes();
                    break;
                case 3:
                    message.chainId = reader.string();
                    break;
                case 4:
                    message.accountNumber = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseSignDoc);
        message.bodyBytes = object.bodyBytes !== undefined && object.bodyBytes !== null ? bytesFromBase64(object.bodyBytes) : new Uint8Array();
        message.authInfoBytes =
            object.authInfoBytes !== undefined && object.authInfoBytes !== null ? bytesFromBase64(object.authInfoBytes) : new Uint8Array();
        message.chainId = object.chainId !== undefined && object.chainId !== null ? String(object.chainId) : '';
        message.accountNumber =
            object.accountNumber !== undefined && object.accountNumber !== null ? long_1.default.fromString(object.accountNumber) : long_1.default.UZERO;
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.bodyBytes !== undefined &&
            (obj.bodyBytes = base64FromBytes(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== undefined &&
            (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = __assign({}, baseSignDoc);
        message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.chainId = (_c = object.chainId) !== null && _c !== void 0 ? _c : '';
        message.accountNumber =
            object.accountNumber !== undefined && object.accountNumber !== null ? long_1.default.fromValue(object.accountNumber) : long_1.default.UZERO;
        return message;
    }
};
var baseMsgUndelegate = { delegatorAddress: '', validatorAddress: '' };
var MsgUndelegate = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.delegatorAddress !== '') {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== '') {
            writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== undefined) {
            Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseMsgUndelegate);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.amount = Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseMsgUndelegate);
        message.delegatorAddress =
            object.delegatorAddress !== undefined && object.delegatorAddress !== null ? String(object.delegatorAddress) : '';
        message.validatorAddress =
            object.validatorAddress !== undefined && object.validatorAddress !== null ? String(object.validatorAddress) : '';
        message.amount = object.amount !== undefined && object.amount !== null ? Coin.fromJSON(object.amount) : undefined;
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = __assign({}, baseMsgUndelegate);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : '';
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : '';
        message.amount = object.amount !== undefined && object.amount !== null ? Coin.fromPartial(object.amount) : undefined;
        return message;
    }
};
var baseMsgDelegate = { delegatorAddress: '', validatorAddress: '' };
var MsgDelegate = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.delegatorAddress !== '') {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== '') {
            writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== undefined) {
            Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseMsgDelegate);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.amount = Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseMsgDelegate);
        message.delegatorAddress =
            object.delegatorAddress !== undefined && object.delegatorAddress !== null ? String(object.delegatorAddress) : '';
        message.validatorAddress =
            object.validatorAddress !== undefined && object.validatorAddress !== null ? String(object.validatorAddress) : '';
        message.amount = object.amount !== undefined && object.amount !== null ? Coin.fromJSON(object.amount) : undefined;
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = __assign({}, baseMsgDelegate);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : '';
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : '';
        message.amount = object.amount !== undefined && object.amount !== null ? Coin.fromPartial(object.amount) : undefined;
        return message;
    }
};
var defaultRegistryTypes = [
    ['/cosmos.bank.v1beta1.MsgSend', MsgSend],
    ['/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward', MsgWithdrawDelegatorReward],
    ['/cosmos.staking.v1beta1.MsgUndelegate', MsgUndelegate],
    ['/cosmos.staking.v1beta1.MsgDelegate', MsgDelegate]
];
function isTxBodyEncodeObject(encodeObject) {
    return encodeObject.typeUrl === '/cosmos.tx.v1beta1.TxBody';
}
var lookupType = function (typeUrl) {
    var types = new Map(__spreadArray([], defaultRegistryTypes, true));
    return types.get(typeUrl);
};
var lookupTypeWithError = function (typeUrl) {
    var type = lookupType(typeUrl);
    if (!type) {
        throw new Error("Unregistered type url: ".concat(typeUrl));
    }
    return type;
};
var encode = function (encodeObject) {
    var value = encodeObject.value, typeUrl = encodeObject.typeUrl;
    if (isTxBodyEncodeObject(encodeObject)) {
        return encodeTxBody(value);
    }
    var type = lookupTypeWithError(typeUrl);
    var instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);
    return type.encode(instance).finish();
};
var encodeAsAny = function (encodeObject) {
    var binaryValue = encode(encodeObject);
    return Any.fromPartial({
        typeUrl: encodeObject.typeUrl,
        value: binaryValue
    });
};
var encodeTxBody = function (txBodyFields) {
    var wrappedMessages = txBodyFields.messages.map(function (message) { return encodeAsAny(message); });
    var txBody = TxBody.fromPartial(__assign(__assign({}, txBodyFields), { messages: wrappedMessages }));
    return TxBody.encode(txBody).finish();
};
var PubKey = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, basePubKey);
        message.key = new Uint8Array();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, basePubKey);
        message.key = object.key !== undefined && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = __assign({}, basePubKey);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function toBase64(data) {
    return base64js.fromByteArray(data);
}
function fromBase64(base64String) {
    if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {
        throw new Error('Invalid base64 string format');
    }
    return base64js.toByteArray(base64String);
}
var encodePubkey = function (pubKey) {
    var pubkeyProto = PubKey.fromPartial({
        key: fromBase64(pubKey.value)
    });
    return Any.fromPartial({
        typeUrl: '/cosmos.crypto.secp256k1.PubKey',
        value: Uint8Array.from(PubKey.encode(pubkeyProto).finish())
    });
};
function encodeSecp256k1Pubkey(pubKey) {
    if (pubKey.length !== 33 || (pubKey[0] !== 0x02 && pubKey[0] !== 0x03)) {
        throw new Error('Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03');
    }
    return {
        type: 'tendermint/PubKeySecp256k1',
        value: toBase64(pubKey)
    };
}
function signModeToJSON(object) {
    switch (object) {
        case SignMode.SIGN_MODE_UNSPECIFIED:
            return 'SIGN_MODE_UNSPECIFIED';
        case SignMode.SIGN_MODE_DIRECT:
            return 'SIGN_MODE_DIRECT';
        case SignMode.SIGN_MODE_TEXTUAL:
            return 'SIGN_MODE_TEXTUAL';
        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
            return 'SIGN_MODE_LEGACY_AMINO_JSON';
        default:
            return 'UNKNOWN';
    }
}
var SignMode;
(function (SignMode) {
    /**
     * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
     * rejected
     */
    SignMode[SignMode["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
    /**
     * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
     * verified with raw bytes from Tx
     */
    SignMode[SignMode["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
    /**
     * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some
     * human-readable textual representation on top of the binary representation
     * from SIGN_MODE_DIRECT
     */
    SignMode[SignMode["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
    /**
     * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
     * Amino JSON and will be removed in the future
     */
    SignMode[SignMode["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
    SignMode[SignMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SignMode || (SignMode = {}));
var signModeFromJSON = function (object) {
    switch (object) {
        case 0:
        case 'SIGN_MODE_UNSPECIFIED':
            return SignMode.SIGN_MODE_UNSPECIFIED;
        case 1:
        case 'SIGN_MODE_DIRECT':
            return SignMode.SIGN_MODE_DIRECT;
        case 2:
        case 'SIGN_MODE_TEXTUAL':
            return SignMode.SIGN_MODE_TEXTUAL;
        case 127:
        case 'SIGN_MODE_LEGACY_AMINO_JSON':
            return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return SignMode.UNRECOGNIZED;
    }
};
var Int53 = /** @class */ (function () {
    function Int53(input) {
        if (Number.isNaN(input)) {
            throw new Error('Input is not a number');
        }
        if (!Number.isInteger(input)) {
            throw new Error('Input is not an integer');
        }
        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {
            throw new Error('Input not in int53 range: ' + input.toString());
        }
        this.data = input;
    }
    Int53.fromString = function (str) {
        if (!str.match(/^-?[0-9]+$/)) {
            throw new Error('Invalid string format');
        }
        return new Int53(Number.parseInt(str, 10));
    };
    Int53.prototype.toNumber = function () {
        return this.data;
    };
    Int53.prototype.toString = function () {
        return this.data.toString();
    };
    return Int53;
}());
var ModeInfo_Single = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.mode !== 0) {
            writer.uint32(8).int32(message.mode);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseModeInfo_Single);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseModeInfo_Single);
        message.mode = object.mode !== undefined && object.mode !== null ? signModeFromJSON(object.mode) : 0;
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = __assign({}, baseModeInfo_Single);
        message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
var baseMsgWithdrawDelegatorReward = { delegatorAddress: '', validatorAddress: '' };
var baseSignerInfo = { sequence: long_1.default.UZERO };
var baseFee = { gasLimit: long_1.default.UZERO, payer: '', granter: '' };
var baseMsgSend = { fromAddress: '', toAddress: '' };
var baseModeInfo_Single = { mode: 0 };
var baseTxRaw = {};
var basePubKey = {};
var baseModeInfo = {};
var baseAuthInfo = {};
var baseAny = { typeUrl: '' };
var baseTxBody = { memo: '', timeoutHeight: long_1.default.UZERO };
var baseCoin = { denom: '', amount: '' };
var ModeInfo = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.single !== undefined) {
            ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseModeInfo);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.single = ModeInfo_Single.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseModeInfo);
        message.single = object.single !== undefined && object.single !== null ? ModeInfo_Single.fromJSON(object.single) : undefined;
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.single !== undefined && (obj.single = message.single ? ModeInfo_Single.toJSON(message.single) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var message = __assign({}, baseModeInfo);
        message.single = object.single !== undefined && object.single !== null ? ModeInfo_Single.fromPartial(object.single) : undefined;
        return message;
    }
};
var SignerInfo = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.publicKey !== undefined) {
            Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.modeInfo !== undefined) {
            ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        }
        if (!message.sequence.isZero()) {
            writer.uint32(24).uint64(message.sequence);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseSignerInfo);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.publicKey = Any.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.modeInfo = ModeInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sequence = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseSignerInfo);
        message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? Any.fromJSON(object.publicKey) : undefined;
        message.modeInfo = object.modeInfo !== undefined && object.modeInfo !== null ? ModeInfo.fromJSON(object.modeInfo) : undefined;
        message.sequence = object.sequence !== undefined && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? Any.toJSON(message.publicKey) : undefined);
        message.modeInfo !== undefined && (obj.modeInfo = message.modeInfo ? ModeInfo.toJSON(message.modeInfo) : undefined);
        message.sequence !== undefined && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial: function (object) {
        var message = __assign({}, baseSignerInfo);
        message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? Any.fromPartial(object.publicKey) : undefined;
        message.modeInfo = object.modeInfo !== undefined && object.modeInfo !== null ? ModeInfo.fromPartial(object.modeInfo) : undefined;
        message.sequence = object.sequence !== undefined && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
    }
};
var Coin = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.denom !== '') {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== '') {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseCoin);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseCoin);
        message.denom = object.denom !== undefined && object.denom !== null ? String(object.denom) : '';
        message.amount = object.amount !== undefined && object.amount !== null ? String(object.amount) : '';
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = __assign({}, baseCoin);
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : '';
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : '';
        return message;
    }
};
var Fee = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        for (var _i = 0, _a = message.amount; _i < _a.length; _i++) {
            var v = _a[_i];
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (!message.gasLimit.isZero()) {
            writer.uint32(16).uint64(message.gasLimit);
        }
        if (message.payer !== '') {
            writer.uint32(26).string(message.payer);
        }
        if (message.granter !== '') {
            writer.uint32(34).string(message.granter);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseFee);
        message.amount = [];
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.amount.push(Coin.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.gasLimit = reader.uint64();
                    break;
                case 3:
                    message.payer = reader.string();
                    break;
                case 4:
                    message.granter = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var _a;
        var message = __assign({}, baseFee);
        message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map(function (e) { return Coin.fromJSON(e); });
        message.gasLimit = object.gasLimit !== undefined && object.gasLimit !== null ? long_1.default.fromString(object.gasLimit) : long_1.default.UZERO;
        message.payer = object.payer !== undefined && object.payer !== null ? String(object.payer) : '';
        message.granter = object.granter !== undefined && object.granter !== null ? String(object.granter) : '';
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        if (message.amount) {
            obj.amount = message.amount.map(function (e) { return (e ? Coin.toJSON(e) : undefined); });
        }
        else {
            obj.amount = [];
        }
        message.gasLimit !== undefined && (obj.gasLimit = (message.gasLimit || long_1.default.UZERO).toString());
        message.payer !== undefined && (obj.payer = message.payer);
        message.granter !== undefined && (obj.granter = message.granter);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = __assign({}, baseFee);
        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map(function (e) { return Coin.fromPartial(e); })) || [];
        message.gasLimit = object.gasLimit !== undefined && object.gasLimit !== null ? long_1.default.fromValue(object.gasLimit) : long_1.default.UZERO;
        message.payer = (_b = object.payer) !== null && _b !== void 0 ? _b : '';
        message.granter = (_c = object.granter) !== null && _c !== void 0 ? _c : '';
        return message;
    }
};
var AuthInfo = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        for (var _i = 0, _a = message.signerInfos; _i < _a.length; _i++) {
            var v = _a[_i];
            SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.fee !== undefined) {
            Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseAuthInfo);
        message.signerInfos = [];
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signerInfos.push(SignerInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.fee = Fee.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var _a;
        var message = __assign({}, baseAuthInfo);
        message.signerInfos = ((_a = object.signerInfos) !== null && _a !== void 0 ? _a : []).map(function (e) { return SignerInfo.fromJSON(e); });
        message.fee = object.fee !== undefined && object.fee !== null ? Fee.fromJSON(object.fee) : undefined;
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        if (message.signerInfos) {
            obj.signerInfos = message.signerInfos.map(function (e) { return (e ? SignerInfo.toJSON(e) : undefined); });
        }
        else {
            obj.signerInfos = [];
        }
        message.fee !== undefined && (obj.fee = message.fee ? Fee.toJSON(message.fee) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = __assign({}, baseAuthInfo);
        message.signerInfos = ((_a = object.signerInfos) === null || _a === void 0 ? void 0 : _a.map(function (e) { return SignerInfo.fromPartial(e); })) || [];
        message.fee = object.fee !== undefined && object.fee !== null ? Fee.fromPartial(object.fee) : undefined;
        return message;
    }
};
var Any = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.typeUrl !== '') {
            writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseAny);
        message.value = new Uint8Array();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.typeUrl = reader.string();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseAny);
        message.typeUrl = object.typeUrl !== undefined && object.typeUrl !== null ? String(object.typeUrl) : '';
        message.value = object.value !== undefined && object.value !== null ? bytesFromBase64(object.value) : new Uint8Array();
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);
        message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = __assign({}, baseAny);
        message.typeUrl = (_a = object.typeUrl) !== null && _a !== void 0 ? _a : '';
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
var TxBody = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        for (var _i = 0, _a = message.messages; _i < _a.length; _i++) {
            var v = _a[_i];
            Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.memo !== '') {
            writer.uint32(18).string(message.memo);
        }
        if (!message.timeoutHeight.isZero()) {
            writer.uint32(24).uint64(message.timeoutHeight);
        }
        for (var _b = 0, _c = message.extensionOptions; _b < _c.length; _b++) {
            var v = _c[_b];
            Any.encode(v, writer.uint32(8186).fork()).ldelim();
        }
        for (var _d = 0, _e = message.nonCriticalExtensionOptions; _d < _e.length; _d++) {
            var v = _e[_d];
            Any.encode(v, writer.uint32(16378).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseTxBody);
        message.messages = [];
        message.extensionOptions = [];
        message.nonCriticalExtensionOptions = [];
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.messages.push(Any.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.memo = reader.string();
                    break;
                case 3:
                    message.timeoutHeight = reader.uint64();
                    break;
                case 1023:
                    message.extensionOptions.push(Any.decode(reader, reader.uint32()));
                    break;
                case 2047:
                    message.nonCriticalExtensionOptions.push(Any.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var _a, _b, _c;
        var message = __assign({}, baseTxBody);
        message.messages = ((_a = object.messages) !== null && _a !== void 0 ? _a : []).map(function (e) { return Any.fromJSON(e); });
        message.memo = object.memo !== undefined && object.memo !== null ? String(object.memo) : '';
        message.timeoutHeight =
            object.timeoutHeight !== undefined && object.timeoutHeight !== null ? long_1.default.fromString(object.timeoutHeight) : long_1.default.UZERO;
        message.extensionOptions = ((_b = object.extensionOptions) !== null && _b !== void 0 ? _b : []).map(function (e) { return Any.fromJSON(e); });
        message.nonCriticalExtensionOptions = ((_c = object.nonCriticalExtensionOptions) !== null && _c !== void 0 ? _c : []).map(function (e) { return Any.fromJSON(e); });
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        if (message.messages) {
            obj.messages = message.messages.map(function (e) { return (e ? Any.toJSON(e) : undefined); });
        }
        else {
            obj.messages = [];
        }
        message.memo !== undefined && (obj.memo = message.memo);
        message.timeoutHeight !== undefined && (obj.timeoutHeight = (message.timeoutHeight || long_1.default.UZERO).toString());
        if (message.extensionOptions) {
            obj.extensionOptions = message.extensionOptions.map(function (e) { return (e ? Any.toJSON(e) : undefined); });
        }
        else {
            obj.extensionOptions = [];
        }
        if (message.nonCriticalExtensionOptions) {
            obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map(function (e) { return (e ? Any.toJSON(e) : undefined); });
        }
        else {
            obj.nonCriticalExtensionOptions = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = __assign({}, baseTxBody);
        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map(function (e) { return Any.fromPartial(e); })) || [];
        message.memo = (_b = object.memo) !== null && _b !== void 0 ? _b : '';
        message.timeoutHeight =
            object.timeoutHeight !== undefined && object.timeoutHeight !== null ? long_1.default.fromValue(object.timeoutHeight) : long_1.default.UZERO;
        message.extensionOptions = ((_c = object.extensionOptions) === null || _c === void 0 ? void 0 : _c.map(function (e) { return Any.fromPartial(e); })) || [];
        message.nonCriticalExtensionOptions = ((_d = object.nonCriticalExtensionOptions) === null || _d === void 0 ? void 0 : _d.map(function (e) { return Any.fromPartial(e); })) || [];
        return message;
    }
};
var TxRaw = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_js_1.default.Writer.create(); }
        if (message.bodyBytes.length !== 0) {
            writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
            writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (var _i = 0, _a = message.signatures; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(26).bytes(v);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_js_1.default.Reader ? input : new minimal_js_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseTxRaw);
        message.signatures = [];
        message.bodyBytes = new Uint8Array();
        message.authInfoBytes = new Uint8Array();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bodyBytes = reader.bytes();
                    break;
                case 2:
                    message.authInfoBytes = reader.bytes();
                    break;
                case 3:
                    message.signatures.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var _a;
        var message = __assign({}, baseTxRaw);
        message.bodyBytes = object.bodyBytes !== undefined && object.bodyBytes !== null ? bytesFromBase64(object.bodyBytes) : new Uint8Array();
        message.authInfoBytes =
            object.authInfoBytes !== undefined && object.authInfoBytes !== null ? bytesFromBase64(object.authInfoBytes) : new Uint8Array();
        message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map(function (e) { return bytesFromBase64(e); });
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.bodyBytes !== undefined &&
            (obj.bodyBytes = base64FromBytes(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== undefined &&
            (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) {
            obj.signatures = message.signatures.map(function (e) { return base64FromBytes(e !== undefined ? e : new Uint8Array()); });
        }
        else {
            obj.signatures = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = __assign({}, baseTxRaw);
        message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.signatures = ((_c = object.signatures) === null || _c === void 0 ? void 0 : _c.map(function (e) { return e; })) || [];
        return message;
    }
};
var makeAuthInfoBytes = function (signers, feeAmount, gasLimit, signMode) {
    if (signMode === void 0) { signMode = 1; }
    var authInfo = {
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
            amount: __spreadArray([], feeAmount, true),
            gasLimit: long_1.default.fromNumber(gasLimit)
        }
    };
    return AuthInfo.encode(AuthInfo.fromPartial(authInfo)).finish();
};
var makeSignerInfos = function (signers, signMode) {
    if (signMode === void 0) { signMode = 1; }
    return signers.map(function (_a) {
        var pubKey = _a.pubKey, sequence = _a.sequence;
        return ({
            publicKey: pubKey,
            modeInfo: {
                single: { mode: signMode }
            },
            sequence: long_1.default.fromNumber(sequence)
        });
    });
};
var bytesFromBase64 = function (b64) {
    var bin = atob(b64);
    var arr = new Uint8Array(bin.length);
    for (var i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
};
var base64FromBytes = function (arr) {
    var bin = [];
    for (var _i = 0, _a = arr; _i < _a.length; _i++) {
        var byte = _a[_i];
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
};
var makeSignDoc = function (bodyBytes, authInfoBytes, chainId, accountNumber) {
    return {
        bodyBytes: bodyBytes,
        authInfoBytes: authInfoBytes,
        chainId: chainId,
        accountNumber: long_1.default.fromNumber(accountNumber)
    };
};
var prepareTxRaw = function (txBodyEncodeObject, fee, Uint8pubKey, sequence, signature, chainId, accountNumber) { return __awaiter(void 0, void 0, void 0, function () {
    var pubKey, txBodyBytes, gasLimit, authInfoBytes, signed;
    return __generator(this, function (_a) {
        pubKey = encodePubkey(encodeSecp256k1Pubkey(Uint8pubKey));
        txBodyBytes = encode(txBodyEncodeObject);
        gasLimit = Int53.fromString(fee.gas).toNumber();
        authInfoBytes = makeAuthInfoBytes([{ pubKey: pubKey, sequence: sequence }], fee.amount, gasLimit);
        signed = makeSignDoc(txBodyBytes, authInfoBytes, chainId, accountNumber);
        return [2 /*return*/, TxRaw.fromPartial({
                bodyBytes: signed.bodyBytes,
                authInfoBytes: signed.authInfoBytes,
                signatures: [fromBase64(signature.signature)]
            })];
    });
}); };
var prepareSignBytes = function (txBodyEncodeObject, fee, pubKey, sequence, chainId, accountNumber) { return __awaiter(void 0, void 0, void 0, function () {
    var encodedPubKey, txBodyBytes, gasLimit, authInfoBytes, signDoc;
    return __generator(this, function (_a) {
        encodedPubKey = encodePubkey(encodeSecp256k1Pubkey(pubKey));
        txBodyBytes = encode(txBodyEncodeObject);
        gasLimit = Int53.fromString(fee.gas).toNumber();
        authInfoBytes = makeAuthInfoBytes([{ pubKey: encodedPubKey, sequence: sequence }], fee.amount, gasLimit);
        signDoc = makeSignDoc(txBodyBytes, authInfoBytes, chainId, accountNumber);
        return [2 /*return*/, makeSignBytes(signDoc)];
    });
}); };
exports.prepareSignBytes = prepareSignBytes;
var makeSignBytes = function (_a) {
    var accountNumber = _a.accountNumber, authInfoBytes = _a.authInfoBytes, bodyBytes = _a.bodyBytes, chainId = _a.chainId;
    var signDoc = SignDoc.fromPartial({
        accountNumber: accountNumber,
        authInfoBytes: authInfoBytes,
        bodyBytes: bodyBytes,
        chainId: chainId
    });
    return SignDoc.encode(signDoc).finish();
};
var encodeTxBytes = function (txBodyEncodeObject, fee, pubKey, sequence, signature, chainId, accountNumber) { return __awaiter(void 0, void 0, void 0, function () {
    var txRaw;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, prepareTxRaw(txBodyEncodeObject, fee, pubKey, sequence, signature, chainId, accountNumber)];
            case 1:
                txRaw = _a.sent();
                return [2 /*return*/, TxRaw.encode(txRaw).finish()];
        }
    });
}); };
exports.encodeTxBytes = encodeTxBytes;
var decodeTxBytes = function (bytes) { return __awaiter(void 0, void 0, void 0, function () {
    var decoded, body, authInfo, messages;
    return __generator(this, function (_a) {
        decoded = TxRaw.decode(bytes);
        body = TxBody.decode(decoded.bodyBytes);
        authInfo = AuthInfo.decode(decoded.authInfoBytes);
        messages = body.messages.map(function (msg) { return ({
            typeUrl: msg.typeUrl,
            value: lookupTypeWithError(msg.typeUrl).decode(msg.value)
        }); });
        return [2 /*return*/, {
                messages: messages,
                memo: body.memo,
                fee: authInfo.fee,
                signerInfos: authInfo.signerInfos
            }];
    });
}); };
exports.decodeTxBytes = decodeTxBytes;
//# sourceMappingURL=index.js.map