"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeAnnots = exports.encodeAnnots = exports.decodeCombPair = exports.primViewDecoder = exports.primDecoder = exports.primEncoder = exports.intDecoder = exports.intEncoder = exports.stringDecoder = exports.stringEncoder = exports.bytesDecoder = exports.bytesEncoder = exports.extractRequiredLen = exports.valueDecoder = exports.valueEncoder = exports.scriptDecoder = exports.scriptEncoder = exports.isInt = exports.isString = exports.isBytes = exports.isPrim = void 0;
var bignumber_1 = require("../../../../../../bignumber.js-9.0.0/bignumber");
var uint8array_consumer_1 = require("../uint8array-consumer");
var constants_1 = require("../constants");
var utils_1 = require("../utils");
var error_1 = require("../error");
var isPrim = function (value) {
    return 'prim' in value;
};
exports.isPrim = isPrim;
var isBytes = function (value) {
    return 'bytes' in value && typeof value.bytes === 'string';
};
exports.isBytes = isBytes;
var isString = function (value) {
    return 'string' in value && typeof value.string === 'string';
};
exports.isString = isString;
var isInt = function (value) {
    return 'int' in value && typeof value.int === 'string';
};
exports.isInt = isInt;
var scriptEncoder = function (script) {
    var code = (0, exports.valueEncoder)(script.code);
    var storage = (0, exports.valueEncoder)(script.storage);
    return "".concat((0, utils_1.pad)(code.length / 2, 8)).concat(code).concat((0, utils_1.pad)(storage.length / 2, 8)).concat(storage);
};
exports.scriptEncoder = scriptEncoder;
var scriptDecoder = function (value) {
    var code = (0, exports.extractRequiredLen)(value);
    var storage = (0, exports.extractRequiredLen)(value);
    return {
        code: (0, exports.valueDecoder)(new uint8array_consumer_1.Uint8ArrayConsumer(code)),
        storage: (0, exports.valueDecoder)(new uint8array_consumer_1.Uint8ArrayConsumer(storage)),
    };
};
exports.scriptDecoder = scriptDecoder;
var valueEncoder = function (value) {
    if (Array.isArray(value)) {
        var encoded = value.map(function (x) { return (0, exports.valueEncoder)(x); }).join('');
        var len = encoded.length / 2;
        return "02".concat((0, utils_1.pad)(len)).concat(encoded);
    }
    else if ((0, exports.isPrim)(value)) {
        return (0, exports.primEncoder)(value);
    }
    else if ((0, exports.isBytes)(value)) {
        return (0, exports.bytesEncoder)(value);
    }
    else if ((0, exports.isString)(value)) {
        return (0, exports.stringEncoder)(value);
    }
    else if ((0, exports.isInt)(value)) {
        return (0, exports.intEncoder)(value);
    }
    throw new error_1.UnexpectedMichelsonValueError(JSON.stringify(value));
};
exports.valueEncoder = valueEncoder;
var valueDecoder = function (value) {
    var preamble = value.consume(1);
    switch (preamble[0]) {
        case 0x0a:
            return (0, exports.bytesDecoder)(value);
        case 0x01:
            return (0, exports.stringDecoder)(value);
        case 0x00:
            return (0, exports.intDecoder)(value);
        case 0x02: {
            var val = new uint8array_consumer_1.Uint8ArrayConsumer((0, exports.extractRequiredLen)(value));
            var results = [];
            while (val.length() > 0) {
                results.push((0, exports.valueDecoder)(val));
            }
            return results;
        }
        default:
            return (0, exports.primDecoder)(value, preamble);
    }
};
exports.valueDecoder = valueDecoder;
var extractRequiredLen = function (value, bytesLength) {
    if (bytesLength === void 0) { bytesLength = 4; }
    var len = value.consume(bytesLength);
    var valueLen = parseInt(Buffer.from(len).toString('hex'), 16);
    return value.consume(valueLen);
};
exports.extractRequiredLen = extractRequiredLen;
var bytesEncoder = function (value) {
    if (!/^([A-Fa-f0-9]{2})*$/.test(value.bytes)) {
        throw new error_1.InvalidHexStringError(value.bytes);
    }
    var len = value.bytes.length / 2;
    return "0a".concat((0, utils_1.pad)(len)).concat(value.bytes);
};
exports.bytesEncoder = bytesEncoder;
var bytesDecoder = function (value) {
    var bytes = (0, exports.extractRequiredLen)(value);
    return {
        bytes: Buffer.from(bytes).toString('hex'),
    };
};
exports.bytesDecoder = bytesDecoder;
var stringEncoder = function (value) {
    var str = Buffer.from(value.string, 'utf8').toString('hex');
    var hexLength = str.length / 2;
    return "01".concat((0, utils_1.pad)(hexLength)).concat(str);
};
exports.stringEncoder = stringEncoder;
var stringDecoder = function (value) {
    var str = (0, exports.extractRequiredLen)(value);
    return {
        string: Buffer.from(str).toString('utf8'),
    };
};
exports.stringDecoder = stringDecoder;
var intEncoder = function (_a) {
    var int = _a.int;
    var num = new bignumber_1.BigNumber(int, 10);
    var positiveMark = num.toString(2)[0] === '-' ? '1' : '0';
    var binary = num.toString(2).replace(/-/g, '');
    var pad = binary.length <= 6
        ? 6
        : (binary.length - 6) % 7
            ? binary.length + 7 - ((binary.length - 6) % 7)
            : binary.length;
    var splitted = binary.padStart(pad, '0').match(/\d{6,7}/g);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var reversed = splitted.reverse();
    reversed[0] = positiveMark + reversed[0];
    var numHex = reversed.map(function (x, i) {
        // Add one to the last chunk
        return parseInt((i === reversed.length - 1 ? '0' : '1') + x, 2)
            .toString(16)
            .padStart(2, '0');
    });
    return "00".concat(numHex.join(''));
};
exports.intEncoder = intEncoder;
var intDecoder = function (value) {
    var c = value.consume(1)[0];
    var hexNumber = [];
    var isNotLastChunkMask = 1 << 7;
    while (c & isNotLastChunkMask) {
        hexNumber.push(c);
        c = value.consume(1)[0];
    }
    hexNumber.push(c);
    var isNegative = !!((1 << 6) & hexNumber[0]);
    hexNumber[0] = hexNumber[0] & 127;
    var numBin = hexNumber
        .map(function (x, i) {
        return x
            .toString(2)
            .slice(i === 0 ? -6 : -7)
            .padStart(i === 0 ? 6 : 7, '0');
    })
        .reverse();
    var num = new bignumber_1.BigNumber(numBin.join(''), 2);
    if (isNegative) {
        num = num.times(-1);
    }
    return {
        int: num.toFixed(),
    };
};
exports.intDecoder = intDecoder;
var primEncoder = function (value) {
    var hasAnnot = +Array.isArray(value.annots);
    var argsCount = Array.isArray(value.args) ? value.args.length : 0;
    // Specify the number of args max is 3 without annotation
    var preamble = (0, utils_1.pad)(Math.min(2 * argsCount + hasAnnot + 0x03, 9), 2);
    var op = constants_1.opMappingReverse[value.prim];
    var encodedArgs = (value.args || []).map(function (arg) { return (0, exports.valueEncoder)(arg); }).join('');
    var encodedAnnots = Array.isArray(value.annots) ? (0, exports.encodeAnnots)(value.annots) : '';
    if ((value.prim === 'LAMBDA' || value.prim === 'LAMBDA_REC') && argsCount) {
        encodedArgs = (0, utils_1.pad)(encodedArgs.length / 2) + encodedArgs + (0, utils_1.pad)(0);
    }
    if ((value.prim === 'pair' || value.prim === 'Pair') && argsCount > 2) {
        encodedArgs =
            encodedAnnots === ''
                ? (0, utils_1.pad)(encodedArgs.length / 2) + encodedArgs + (0, utils_1.pad)(0)
                : (0, utils_1.pad)(encodedArgs.length / 2) + encodedArgs;
    }
    if (value.prim === 'view' && value.args) {
        encodedArgs = (0, utils_1.pad)(encodedArgs.length / 2) + encodedArgs + (0, utils_1.pad)(0);
    }
    return "".concat(preamble).concat(op).concat(encodedArgs).concat(encodedAnnots);
};
exports.primEncoder = primEncoder;
var primDecoder = function (value, preamble) {
    var hasAnnot = (preamble[0] - 0x03) % 2 === 1;
    var argsCount = Math.floor((preamble[0] - 0x03) / 2);
    var op = value.consume(1)[0].toString(16).padStart(2, '0');
    var result = {
        prim: constants_1.opMapping[op],
    };
    if (constants_1.opMapping[op] === 'LAMBDA' || constants_1.opMapping[op] === 'LAMBDA_REC') {
        value.consume(4);
    }
    if (constants_1.opMapping[op] === 'view') {
        if (argsCount != 0) {
            return (0, exports.primViewDecoder)(value, result);
        }
        else {
            return result;
        }
    }
    var combPairArgs;
    var combPairAnnots;
    if ((constants_1.opMapping[op] === 'pair' || constants_1.opMapping[op] === 'Pair') && argsCount > 2) {
        combPairArgs = (0, exports.decodeCombPair)(value);
        argsCount = 0;
        combPairAnnots = (0, exports.decodeAnnots)(value);
    }
    var args = new Array(argsCount).fill(0).map(function () { return (0, exports.valueDecoder)(value); });
    if (constants_1.opMapping[op] === 'LAMBDA' || constants_1.opMapping[op] === 'LAMBDA_REC') {
        value.consume(4);
    }
    if (combPairArgs) {
        result['args'] = combPairArgs;
    }
    else if (args.length) {
        result['args'] = args;
    }
    if (combPairAnnots && combPairAnnots[0] !== '') {
        result['annots'] = combPairAnnots;
    }
    else if (hasAnnot) {
        result['annots'] = (0, exports.decodeAnnots)(value);
    }
    return result;
};
exports.primDecoder = primDecoder;
var primViewDecoder = function (value, result) {
    value.consume(4);
    result['args'] = new Array(4).fill(0).map(function () { return (0, exports.valueDecoder)(value); });
    value.consume(4);
    return result;
};
exports.primViewDecoder = primViewDecoder;
var decodeCombPair = function (val) {
    var array = new uint8array_consumer_1.Uint8ArrayConsumer((0, exports.extractRequiredLen)(val));
    var args = [];
    while (array.length() > 0) {
        args.push((0, exports.valueDecoder)(array));
    }
    return args;
};
exports.decodeCombPair = decodeCombPair;
var encodeAnnots = function (value) {
    var mergedAnnot = value
        .map(function (x) {
        return Buffer.from(x, 'utf8').toString('hex');
    })
        .join('20');
    var len = mergedAnnot.length / 2;
    return "".concat((0, utils_1.pad)(len)).concat(mergedAnnot);
};
exports.encodeAnnots = encodeAnnots;
var decodeAnnots = function (val) {
    var len = val.consume(4);
    var annotLen = parseInt(Buffer.from(len).toString('hex'), 16);
    var restOfAnnot = val.consume(annotLen);
    var restOfAnnotHex = Buffer.from(restOfAnnot).toString('hex');
    return restOfAnnotHex.split('20').map(function (x) { return Buffer.from(x, 'hex').toString('utf8'); });
};
exports.decodeAnnots = decodeAnnots;
//# sourceMappingURL=codec.js.map