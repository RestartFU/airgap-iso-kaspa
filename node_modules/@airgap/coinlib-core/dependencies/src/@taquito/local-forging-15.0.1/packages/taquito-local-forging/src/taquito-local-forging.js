"use strict";
/**
 * @packageDocumentation
 * @module @taquito/local-forging
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.localForger = exports.LocalForger = exports.getCodec = exports.ProtocolsHash = exports.VERSION = exports.opMappingReverse = exports.opMapping = exports.CODEC = void 0;
var constants_1 = require("./constants");
var decoder_1 = require("./decoder");
var encoder_1 = require("./encoder");
var uint8array_consumer_1 = require("./uint8array-consumer");
var taquito_utils_1 = require("../../../../../@taquito/utils-15.0.1/packages/taquito-utils/src/taquito-utils");
var error_1 = require("./error");
var validator_1 = require("./validator");
var protocols_1 = require("./protocols");
var decoder_proto14_1 = require("./proto14-kathmandu/decoder-proto14");
var encoder_proto14_1 = require("./proto14-kathmandu/encoder-proto14");
var constants_2 = require("./constants");
Object.defineProperty(exports, "CODEC", { enumerable: true, get: function () { return constants_2.CODEC; } });
Object.defineProperty(exports, "opMapping", { enumerable: true, get: function () { return constants_2.opMapping; } });
Object.defineProperty(exports, "opMappingReverse", { enumerable: true, get: function () { return constants_2.opMappingReverse; } });
__exportStar(require("./decoder"), exports);
__exportStar(require("./encoder"), exports);
__exportStar(require("./uint8array-consumer"), exports);
__exportStar(require("./interface"), exports);
var version_1 = require("./version");
Object.defineProperty(exports, "VERSION", { enumerable: true, get: function () { return version_1.VERSION; } });
var protocols_2 = require("./protocols");
Object.defineProperty(exports, "ProtocolsHash", { enumerable: true, get: function () { return protocols_2.ProtocolsHash; } });
var PROTOCOL_CURRENT = protocols_1.ProtocolsHash.PtLimaPtL;
function getCodec(codec, _proto) {
    // use proto14 encoders & decoders if it's kathmandu or prior
    if (_proto === protocols_1.ProtocolsHash.PtKathman || (0, protocols_1.ProtoInferiorTo)(_proto, PROTOCOL_CURRENT)) {
        return {
            encoder: encoder_proto14_1.encodersProto14[codec],
            decoder: function (hex) {
                var consumer = uint8array_consumer_1.Uint8ArrayConsumer.fromHexString(hex);
                return decoder_proto14_1.decodersProto14[codec](consumer);
            },
        };
    }
    else {
        return {
            encoder: encoder_1.encoders[codec],
            decoder: function (hex) {
                var consumer = uint8array_consumer_1.Uint8ArrayConsumer.fromHexString(hex);
                return decoder_1.decoders[codec](consumer);
            },
        };
    }
}
exports.getCodec = getCodec;
var LocalForger = /** @class */ (function () {
    function LocalForger(protocolHash) {
        if (protocolHash === void 0) { protocolHash = PROTOCOL_CURRENT; }
        this.protocolHash = protocolHash;
        this.codec = getCodec(constants_1.CODEC.MANAGER, this.protocolHash);
    }
    LocalForger.prototype.forge = function (params) {
        if ((0, taquito_utils_1.validateBlock)(params.branch) !== taquito_utils_1.ValidationResult.VALID) {
            throw new error_1.InvalidBlockHashError("The block hash ".concat(params.branch, " is invalid"));
        }
        for (var _i = 0, _a = params.contents; _i < _a.length; _i++) {
            var content = _a[_i];
            if (!(0, validator_1.validateOperationKind)(content.kind)) {
                throw new taquito_utils_1.InvalidOperationKindError(content.kind);
            }
            var diff = (0, validator_1.validateMissingProperty)(content);
            if (diff.length === 1) {
                if (content.kind === 'delegation' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'origination' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'transaction' && diff[0] === 'parameters') {
                    continue;
                }
                else if (content.kind === 'tx_rollup_submit_batch' &&
                    diff[0] === 'burn_limit') {
                    continue;
                }
                else {
                    throw new error_1.InvalidOperationSchemaError("Missing properties: ".concat(diff.join(', ').toString()));
                }
            }
            else if (diff.length > 1) {
                throw new error_1.InvalidOperationSchemaError("Missing properties: ".concat(diff.join(', ').toString()));
            }
        }
        var forged = this.codec.encoder(params).toLowerCase();
        return Promise.resolve(forged);
    };
    LocalForger.prototype.parse = function (hex) {
        return Promise.resolve(this.codec.decoder(hex));
    };
    return LocalForger;
}());
exports.LocalForger = LocalForger;
exports.localForger = new LocalForger();
//# sourceMappingURL=taquito-local-forging.js.map