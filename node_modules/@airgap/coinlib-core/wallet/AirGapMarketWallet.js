"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirGapMarketWallet = void 0;
var bignumber_1 = __importDefault(require("../dependencies/src/bignumber.js-9.0.0/bignumber"));
var ProtocolSymbols_1 = require("../utils/ProtocolSymbols");
var AirGapWallet_1 = require("./AirGapWallet");
var AirGapMarketWallet = /** @class */ (function (_super) {
    __extends(AirGapMarketWallet, _super);
    function AirGapMarketWallet(protocol, publicKey, isExtendedPublicKey, derivationPath, masterFingerprint, status, priceService, addressIndex) {
        var _this = _super.call(this, protocol, publicKey, isExtendedPublicKey, derivationPath, masterFingerprint, status, addressIndex) || this;
        _this.protocol = protocol;
        _this.publicKey = publicKey;
        _this.isExtendedPublicKey = isExtendedPublicKey;
        _this.derivationPath = derivationPath;
        _this.masterFingerprint = masterFingerprint;
        _this.status = status;
        _this.priceService = priceService;
        _this.addressIndex = addressIndex;
        return _this;
    }
    AirGapMarketWallet.prototype.addressesToCheck = function () {
        var addressesToReceive = this.addressIndex !== undefined ? [this.addresses[this.addressIndex]] : this.addresses;
        return addressesToReceive;
    };
    AirGapMarketWallet.prototype.setProtocol = function (protocol) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, _super.prototype.setProtocol.call(this, protocol)];
                    case 1:
                        _a.sent();
                        this.reset();
                        return [4 /*yield*/, this.synchronize()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    AirGapMarketWallet.prototype.synchronize = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.synchronizePromise === undefined) {
                    this.synchronizePromise = this._synchronize.apply(this, args).finally(function () {
                        _this.synchronizePromise = undefined;
                    });
                }
                return [2 /*return*/, this.synchronizePromise];
            });
        });
    };
    AirGapMarketWallet.prototype.fetchTransactions = function (limit, cursor) {
        return __awaiter(this, void 0, void 0, function () {
            var protocolIdentifier, transactionResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protocol.getIdentifier()
                        // let transactions: IAirGapTransaction[] = []
                    ];
                    case 1:
                        protocolIdentifier = _a.sent();
                        if (!((protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.BTC ||
                            protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.BTC_SEGWIT ||
                            protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.GRS) &&
                            this.isExtendedPublicKey)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.protocol.getTransactionsFromExtendedPublicKey(this.publicKey, limit, cursor)];
                    case 2:
                        // TODO: Remove and test
                        /*
                        We should remove this if BTC also uses blockbook. (And change the order of the if/else below)
                        
                        The problem is that we have addresses cached for all protocols. But blockbook (grs) doesn't allow
                        multiple addresses to be checked at once, so we need to xPub key there (or we would do 100s of requests).
                  
                        We can also not simply change the order of the following if/else, because then it would use the xPub method for
                        BTC as well, which results in the addresses being derived again, which causes massive lags in the apps.
                        */
                        transactionResult = _a.sent();
                        return [3 /*break*/, 11];
                    case 3:
                        if (!(protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.XTZ_SHIELDED) /* TODO: cover ALL sapling protocols */) return [3 /*break*/, 5]; /* TODO: cover ALL sapling protocols */
                        return [4 /*yield*/, this.protocol.getTransactionsFromPublicKey(this.publicKey, limit, cursor)];
                    case 4:
                        transactionResult = _a.sent();
                        return [3 /*break*/, 11];
                    case 5:
                        if (!(this.addresses.length > 0)) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.protocol.getTransactionsFromAddresses(this.addressesToCheck(), limit, cursor)];
                    case 6:
                        transactionResult = _a.sent();
                        return [3 /*break*/, 11];
                    case 7:
                        if (!this.isExtendedPublicKey) return [3 /*break*/, 9];
                        return [4 /*yield*/, this.protocol.getTransactionsFromExtendedPublicKey(this.publicKey, limit, cursor)];
                    case 8:
                        transactionResult = _a.sent();
                        return [3 /*break*/, 11];
                    case 9: return [4 /*yield*/, this.protocol.getTransactionsFromPublicKey(this.publicKey, limit, cursor)];
                    case 10:
                        transactionResult = _a.sent();
                        _a.label = 11;
                    case 11: return [2 /*return*/, transactionResult];
                }
            });
        });
    };
    AirGapMarketWallet.prototype.prepareTransaction = function (recipients, values, fee, data) {
        if (data === void 0) { data = {}; }
        if (this.isExtendedPublicKey) {
            return this.protocol.prepareTransactionFromExtendedPublicKey(this.publicKey, 0, recipients, values, fee, data);
        }
        else {
            if (this.addressIndex) {
                data = Object.assign(data, { addressIndex: this.addressIndex });
            }
            return this.protocol.prepareTransactionFromPublicKey(this.publicKey, recipients, values, fee, data);
        }
    };
    AirGapMarketWallet.prototype.getMaxTransferValue = function (recipients, fee, data) {
        if (data === void 0) { data = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!this.isExtendedPublicKey) return [3 /*break*/, 2];
                        _a = bignumber_1.default.bind;
                        return [4 /*yield*/, this.protocol.estimateMaxTransactionValueFromExtendedPublicKey(this.publicKey, recipients, fee, data)];
                    case 1: return [2 /*return*/, new (_a.apply(bignumber_1.default, [void 0, _c.sent()]))()];
                    case 2:
                        if (this.addressIndex) {
                            data = Object.assign(data, { addressIndex: this.addressIndex });
                        }
                        _b = bignumber_1.default.bind;
                        return [4 /*yield*/, this.protocol.estimateMaxTransactionValueFromPublicKey(this.publicKey, recipients, fee, data)];
                    case 3: return [2 /*return*/, new (_b.apply(bignumber_1.default, [void 0, _c.sent()]))()];
                }
            });
        });
    };
    AirGapMarketWallet.prototype.estimateFees = function (recipients, values, data) {
        if (data === void 0) { data = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.isExtendedPublicKey) {
                    return [2 /*return*/, this.protocol.estimateFeeDefaultsFromExtendedPublicKey(this.publicKey, recipients, values, data)];
                }
                else {
                    if (this.addressIndex) {
                        data = Object.assign(data, { addressIndex: this.addressIndex });
                    }
                    return [2 /*return*/, this.protocol.estimateFeeDefaultsFromPublicKey(this.publicKey, recipients, values, data)];
                }
                return [2 /*return*/];
            });
        });
    };
    return AirGapMarketWallet;
}(AirGapWallet_1.AirGapWallet));
exports.AirGapMarketWallet = AirGapMarketWallet;
//# sourceMappingURL=AirGapMarketWallet.js.map