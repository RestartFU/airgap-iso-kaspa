"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirGapCoinWallet = exports.TimeInterval = void 0;
var bignumber_1 = __importDefault(require("../dependencies/src/bignumber.js-9.0.0/bignumber"));
var ProtocolNetwork_1 = require("../utils/ProtocolNetwork");
var ProtocolSymbols_1 = require("../utils/ProtocolSymbols");
var AirGapMarketWallet_1 = require("./AirGapMarketWallet");
var TimeInterval;
(function (TimeInterval) {
    TimeInterval["HOURS"] = "24h";
    TimeInterval["DAYS"] = "7d";
    TimeInterval["MONTH"] = "30d";
})(TimeInterval = exports.TimeInterval || (exports.TimeInterval = {}));
var AirGapCoinWallet = /** @class */ (function (_super) {
    __extends(AirGapCoinWallet, _super);
    function AirGapCoinWallet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AirGapCoinWallet.prototype.getCurrentBalance = function () {
        return this.currentBalance;
    };
    AirGapCoinWallet.prototype.setCurrentBalance = function (balance) {
        this.currentBalance = balance;
    };
    AirGapCoinWallet.prototype.getCurrentMarketPrice = function () {
        return this.currentMarketPrice;
    };
    AirGapCoinWallet.prototype.setCurrentMarketPrice = function (marketPrice) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.protocol.getOptions()];
                    case 1:
                        _a.currentMarketPrice = (_b.sent()).network.type === ProtocolNetwork_1.NetworkType.MAINNET ? marketPrice : new bignumber_1.default(0);
                        return [2 /*return*/];
                }
            });
        });
    };
    AirGapCoinWallet.prototype._synchronize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, balance, marketPrice;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, Promise.all([this.balanceOf(), this.fetchCurrentMarketPrice()])];
                    case 1:
                        _a = _b.sent(), balance = _a[0], marketPrice = _a[1];
                        this.setCurrentBalance(balance);
                        return [4 /*yield*/, this.setCurrentMarketPrice(marketPrice)];
                    case 2:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    AirGapCoinWallet.prototype.reset = function () {
        this.currentBalance = undefined;
        this.currentMarketPrice = undefined;
    };
    AirGapCoinWallet.prototype.fetchCurrentMarketPrice = function (baseSymbol) {
        if (baseSymbol === void 0) { baseSymbol = 'USD'; }
        return __awaiter(this, void 0, void 0, function () {
            var marketPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.priceService.getCurrentMarketPrice(this.protocol, baseSymbol)];
                    case 1:
                        marketPrice = _a.sent();
                        return [4 /*yield*/, this.setCurrentMarketPrice(marketPrice)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, marketPrice];
                }
            });
        });
    };
    AirGapCoinWallet.prototype.balanceOf = function () {
        return __awaiter(this, void 0, void 0, function () {
            var protocolIdentifier, result, _a, _b, _c, _d, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0: return [4 /*yield*/, this.protocol.getIdentifier()];
                    case 1:
                        protocolIdentifier = _f.sent();
                        if (!((protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.BTC ||
                            protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.BTC_SEGWIT ||
                            protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.GRS) &&
                            this.isExtendedPublicKey)) return [3 /*break*/, 3];
                        _a = bignumber_1.default.bind;
                        return [4 /*yield*/, this.protocol.getBalanceOfExtendedPublicKey(this.publicKey, 0)];
                    case 2:
                        // TODO: Remove and test
                        /*
                        We should remove this if BTC also uses blockbook. (And change the order of the if/else below)
                        
                        The problem is that we have addresses cached for all protocols. But blockbook (grs) doesn't allow
                        multiple addresses to be checked at once, so we need to xPub key there (or we would do 100s of requests).
                  
                        We can also not simply change the order of the following if/else, because then it would use the xPub method for
                        BTC as well, which results in the addresses being derived again, which causes massive lags in the apps.
                        */
                        result = new (_a.apply(bignumber_1.default, [void 0, _f.sent()]))();
                        return [3 /*break*/, 11];
                    case 3:
                        if (!(protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.XTZ_SHIELDED /* TODO: cover ALL sapling protocols */ ||
                            protocolIdentifier === ProtocolSymbols_1.MainProtocolSymbols.ICP)) return [3 /*break*/, 5];
                        _b = bignumber_1.default.bind;
                        return [4 /*yield*/, this.protocol.getBalanceOfPublicKey(this.publicKey)];
                    case 4:
                        result = new (_b.apply(bignumber_1.default, [void 0, _f.sent()]))();
                        return [3 /*break*/, 11];
                    case 5:
                        if (!(this.addresses.length > 0)) return [3 /*break*/, 7];
                        _c = bignumber_1.default.bind;
                        return [4 /*yield*/, this.protocol.getBalanceOfAddresses(this.addressesToCheck())];
                    case 6:
                        result = new (_c.apply(bignumber_1.default, [void 0, _f.sent()]))();
                        return [3 /*break*/, 11];
                    case 7:
                        if (!this.isExtendedPublicKey) return [3 /*break*/, 9];
                        _d = bignumber_1.default.bind;
                        return [4 /*yield*/, this.protocol.getBalanceOfExtendedPublicKey(this.publicKey, 0)];
                    case 8:
                        result = new (_d.apply(bignumber_1.default, [void 0, _f.sent()]))();
                        return [3 /*break*/, 11];
                    case 9:
                        _e = bignumber_1.default.bind;
                        return [4 /*yield*/, this.protocol.getBalanceOfPublicKey(this.publicKey)];
                    case 10:
                        result = new (_e.apply(bignumber_1.default, [void 0, _f.sent()]))();
                        _f.label = 11;
                    case 11:
                        this.setCurrentBalance(result);
                        return [2 /*return*/, result];
                }
            });
        });
    };
    return AirGapCoinWallet;
}(AirGapMarketWallet_1.AirGapMarketWallet));
exports.AirGapCoinWallet = AirGapCoinWallet;
//# sourceMappingURL=AirGapCoinWallet.js.map