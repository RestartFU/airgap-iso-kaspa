import BigNumber from '../dependencies/src/bignumber.js-9.0.0/bignumber';
import { IAirGapTransaction, IAirGapTransactionResult, IProtocolTransactionCursor } from '../interfaces/IAirGapTransaction';
import { FeeDefaults, ICoinProtocol } from '../protocols/ICoinProtocol';
import { AirGapWallet, AirGapWalletStatus } from './AirGapWallet';
export interface AirGapWalletPriceService {
    getCurrentMarketPrice(protocol: ICoinProtocol, baseSymbol: string): Promise<BigNumber>;
}
export declare abstract class AirGapMarketWallet extends AirGapWallet {
    protocol: ICoinProtocol;
    publicKey: string;
    isExtendedPublicKey: boolean;
    derivationPath: string;
    masterFingerprint: string;
    status: AirGapWalletStatus;
    priceService: AirGapWalletPriceService;
    addressIndex?: number | undefined;
    private synchronizePromise?;
    constructor(protocol: ICoinProtocol, publicKey: string, isExtendedPublicKey: boolean, derivationPath: string, masterFingerprint: string, status: AirGapWalletStatus, priceService: AirGapWalletPriceService, addressIndex?: number | undefined);
    abstract getCurrentBalance(...args: any): BigNumber | undefined;
    abstract setCurrentBalance(balance: BigNumber | undefined, ...args: any): void;
    abstract getCurrentMarketPrice(...args: any): BigNumber | undefined;
    abstract setCurrentMarketPrice(balance: BigNumber | undefined, ...args: any): void;
    abstract fetchCurrentMarketPrice(...args: any): Promise<BigNumber>;
    abstract balanceOf(...args: any): Promise<BigNumber>;
    protected abstract _synchronize(...args: any): Promise<void>;
    protected abstract reset(): void;
    protected addressesToCheck(): string[];
    setProtocol(protocol: ICoinProtocol): Promise<void>;
    synchronize(...args: any): Promise<void>;
    fetchTransactions(limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;
    prepareTransaction(recipients: string[], values: string[], fee: string, data?: {
        [key: string]: unknown;
    }): Promise<IAirGapTransaction>;
    getMaxTransferValue(recipients: string[], fee?: string, data?: {
        [key: string]: unknown;
    }): Promise<BigNumber>;
    estimateFees(recipients: string[], values: string[], data?: {
        [key: string]: unknown;
    }): Promise<FeeDefaults>;
}
