"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.changeEndianness = exports.bytesToHex = exports.hexToBytes = exports.toHexString = exports.toHexStringRaw = exports.toHexBuffer = exports.isHex = exports.stripHexPrefix = exports.addHexPrefix = void 0;
var bignumber_1 = __importDefault(require("../dependencies/src/bignumber.js-9.0.0/bignumber"));
var padStart_1 = require("./padStart");
var HEX_PREFIX = '0x';
var HEX_REGEX = new RegExp("^(".concat(HEX_PREFIX, ")?[0-9a-fA-F]*$"));
function hasPrefix(value) {
    return value.startsWith(HEX_PREFIX);
}
function addHexPrefix(raw) {
    return hasPrefix(raw) ? raw : HEX_PREFIX + raw;
}
exports.addHexPrefix = addHexPrefix;
function stripHexPrefix(hex) {
    return hasPrefix(hex) ? hex.substring(2) : hex;
}
exports.stripHexPrefix = stripHexPrefix;
function isHex(value) {
    return HEX_REGEX.test(value);
}
exports.isHex = isHex;
function toHexBuffer(value, bitLength, encoding) {
    if (bitLength === void 0) { bitLength = 8; }
    if (encoding === void 0) { encoding = 'default'; }
    return Buffer.from(toHexStringRaw(value, bitLength, encoding), 'hex');
}
exports.toHexBuffer = toHexBuffer;
function toHexStringRaw(value, bitLength, encoding) {
    if (bitLength === void 0) { bitLength = 8; }
    if (encoding === void 0) { encoding = '2sComplement'; }
    if (new bignumber_1.default(value).isPositive()) {
        return toHexStringRawPositive(value, bitLength);
    }
    else {
        return toHexStringRawNegative(value, bitLength, encoding);
    }
}
exports.toHexStringRaw = toHexStringRaw;
function toHexString(value, bitLength, encoding) {
    if (bitLength === void 0) { bitLength = 8; }
    if (encoding === void 0) { encoding = 'default'; }
    return addHexPrefix(toHexStringRaw(value, bitLength, encoding));
}
exports.toHexString = toHexString;
function hexToBytes(hex, bitLength) {
    var byteLength = bitLength !== undefined ? Math.ceil(bitLength / 8) : undefined;
    var buffer;
    if (typeof hex === 'string' && isHex(hex)) {
        buffer = Buffer.from(stripHexPrefix(hex), 'hex');
    }
    else if (!(typeof hex === 'string')) {
        buffer = Buffer.from(hex);
    }
    else {
        buffer = Buffer.from([0]);
    }
    if (byteLength !== undefined && buffer.length < byteLength) {
        var newBuffer = Buffer.alloc(byteLength, 0);
        var offset = newBuffer.length - buffer.length;
        buffer.copy(newBuffer, offset);
        return newBuffer;
    }
    else {
        return buffer;
    }
}
exports.hexToBytes = hexToBytes;
function bytesToHex(bytes, config) {
    var hex;
    if (typeof bytes === 'string') {
        hex = bytes;
    }
    else {
        var buffer = Buffer.isBuffer(bytes) ? bytes : Buffer.from(bytes);
        hex = buffer.toString('hex');
    }
    return (config === null || config === void 0 ? void 0 : config.withPrefix) ? addHexPrefix(hex) : hex;
}
exports.bytesToHex = bytesToHex;
function changeEndianness(hex) {
    var _hex = stripHexPrefix(hex);
    _hex = _hex.length % 2 !== 0 ? '0' + _hex : _hex;
    var bytes = _hex.match(/.{2}/g) || [];
    return bytes.reverse().join('');
}
exports.changeEndianness = changeEndianness;
function toHexStringRawPositive(value, bitLength) {
    var hexString = value.toString(16);
    return fillToTargetLength(hexString, bitLength);
}
function toHexStringRawNegative(value, bitLength, encoding) {
    // tslint:disable-next-line: switch-default
    switch (encoding) {
        case 'default':
            var hexString = value.toString(16);
            return hexString.startsWith('-') ? "-".concat(fillToTargetLength(hexString.substr(1), bitLength)) : fillToTargetLength(hexString, bitLength);
        case '2sComplement':
            var value2sComplement = new bignumber_1.default(2).pow(bitLength).minus(new bignumber_1.default(value).abs());
            return value2sComplement.toString(16);
    }
}
function fillToTargetLength(hexString, bitLength) {
    var nibbleLength = Math.ceil(bitLength / 4);
    var targetLength = hexString.length >= nibbleLength ? hexString.length : nibbleLength;
    targetLength = targetLength % 2 === 0 ? targetLength : targetLength + 1;
    return (0, padStart_1.padStart)(hexString, targetLength, '0');
}
//# sourceMappingURL=hex.js.map